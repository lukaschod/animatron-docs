<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Architecture </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Architecture ">
    <meta name="generator" content="docfx ">
  
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
  
  <meta property="docfx:rel" content="../">
  
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="architecture">Architecture</h1>

<p>In this section, we’ll cover the general architecture of the package. As the package is built with extensibility in mind, this will go into more technical detail about how the package functions to familiarize the user with key concepts.</p>
<p>The package works with both traditional GameObjects (a.k.a. hybrid) and ECS subscenes using the same authoring components (e.g., <code>MonoBehaviours</code>). However, in both use cases, all logic runs in the ECS world, and the authoring components merely contain logic to set up entities. In the hybrid scenario, during <code>MonoBehaviour</code> setup, it also creates an <code>Entity</code> that gets connected with the GameObject's lifetime and adds components that are connected with the authoring component. For the subscene workflow, it follows general Unity concepts, so for more details, it is recommended to check Unity’s <code>com.unity.entities</code> package documentation about subscenes.</p>
<p>The other sections will cover the authoring components, entity components, and systems. Keep in mind this only covers the core elements of the package for simplicity. The package contains more components, but they follow this structure quite strictly.</p>
<h2 id="authoring">Authoring</h2>
<p>Each animated object will contain at minimum the following structure. There is a parent GameObject that contains the <code>Animatron</code> component, which is the main component. It references the <code>Rig</code> ScriptableObject that is baked at edit time and contains the bone structure and animation data.</p>
<p>Then it contains one or more child GameObjects, referred to as <code>Skin</code>, where each of them at the very least contains a <code>RenderMeshArray</code>. <code>RenderMeshArray</code> is a general-purpose rendering component that replaces the <code>SkinnedMeshRenderer</code>.</p>
<p>It is a helpful analogy to think of the parent GameObject with <code>Animatron</code> as the bones of a body, and the <code>Skin</code> objects as the flesh that gets rendered—usually bound to a subset of bones or all of them.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Note: <code>RenderMeshArray</code> can be used as a standalone component that essentially works as a <code>MeshRenderer</code>. There are multiple benefits to using it instead of Unity’s built-in <code>MeshRenderer</code>. For more details, read the section about <code>RenderMeshArray</code>.</p>
</div>
<h2 id="entity">Entity</h2>
<p>Entities follow a structure similar to authoring, but with more granular components. There is a parent entity that contains several key components. The first is an optional <code>Animatron</code>, which simply plays an animation at a given index. Next, it contains a <code>JointPose</code> buffer, which is an array of transforms representing the entity’s pose at the current frame. It also has references to <code>Armature</code> and <code>Motion</code>. <code>Armature</code> and <code>Motion</code> are generated by the <code>Rig</code>. <code>Armature</code> is a compact binary blob that contains joint data, while <code>Motion</code> is another compact blob containing animation data.</p>
<p>Similarly to authoring, there are one or more child entities. They reference the same <code>Armature</code> and also contain a <code>SkinMatrix</code> buffer, which is an array of transforms derived from a subset of the parent’s <code>JointPose</code>.</p>
<p>There is also a singleton entity that contains the <code>SkinMatrixBuffer</code> component. This holds all <code>SkinMatrix</code> buffers from all entities, flattened into a single array and stored in GPU memory. It is later bound to shaders for deformation. Each entity also contains a <code>SkinMatrixBufferIndex</code>, which is simply an offset into this buffer and is regenerated each frame.</p>
<h2 id="systems">Systems</h2>
<p>Most of the system logic runs in a system group called <code>AnimatronSystemGroup</code>. Here is a simplified execution order of systems and what they do:</p>
<ul>
<li><code>AnimatronSystemGroup</code> contains systems:
<ul>
<li><code>AnimatronSystem</code>: Plays the current animation by writing transforms into <code>JointPose</code>. This is optional, and users can implement more advanced systems here—e.g., playing multiple animations on different joints or using a custom animation graph.</li>
<li>Animation post-processing: This can be user-defined or, in this package’s case, includes blending (e.g., crossfade, inertialization, inverse kinematics, etc.).</li>
<li><code>PoseSystem</code>: Transforms the <code>JointPose</code> array from local space to object space.</li>
<li><code>SkinSystem</code>: Updates the <code>SkinMatrix</code> array from the parent’s <code>JointPose</code> and applies the bind pose transform, since this matrix will be used by the GPU. For more details, read the code or look up how skinning matrices are typically calculated.</li>
<li><code>SkinMatrixSystem</code>: This includes several systems that execute at different stages for performance reasons. Their main purpose is to flatten all <code>SkinMatrix</code> data from all entities into the singleton <code>SkinMatrixBuffer</code> in GPU memory. It also binds this GPU memory to the shader.</li>
</ul>
</li>
</ul>
<p>After this, the Unity Entities Graphics package takes over, issuing draw calls for each <code>RenderMeshArray</code>. Since <code>SkinMatrixBuffer</code> contains all skin matrices in a single buffer, and each entity contains instance data like <code>SkinMatrixBufferIndex</code>, the shader can easily access the correct transforms.</p>
<p>In theory, other rendering solutions can also be used, as long as they correctly gather all entities' <code>SkinMatrixBufferIndex</code> components and pass them to the GPU as instanced data.</p>
</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      
      <span>Copyright © ProjectDawn.<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
